<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>app/components/exp-lookit-change-detection/component.js - ember-lookit-frameplayer</title>
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="https://yui-s.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="https://yui-s.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">
<div id="doc">
    <div id="bd" class="yui3-g">
        <div class="yui3-u-1-5">
            <div id="docs-sidebar" class="sidebar apidocs">
              <h2 style="display:inline;">
              <div>
                <img style="float:right; vertical-align:middle;" src="../assets/css/logo.png" height="70">
                <span>Lookit<br> component<br> docs</span>
              </div>

              </h2>


              <div id="api-list">
                  <div id="api-tabview">
              
                    <div id="api-tabview-panel">
                        <h2 class="off-left">Collections</h2>
                        <ul id="api-modules" class="apis modules">
                            <li class="module-sidebar-exp-player"><a href="../modules/exp-player.html">exp-player</a></li>
                            <li class="module-sidebar-frames"><a href="../modules/frames.html">frames</a></li>
                            <li class="module-sidebar-mixins"><a href="../modules/mixins.html">mixins</a></li>
                            <li class="module-sidebar-randomizers"><a href="../modules/randomizers.html">randomizers</a></li>
                        </ul>
                        <h2 class="off-left">All elements</h2>
                              <div id="api-tabview-filter">
                      <input type="search" id="api-filter" placeholder="Type to filter">
                    </div>
                        <ul id="api-classes" class="apis classes">
                            <li><a href="../classes/Exp-frame-base.html">Exp-frame-base</a></li>
                            <li><a href="../classes/Exp-frame-select.html">Exp-frame-select</a></li>
                            <li><a href="../classes/Exp-lookit-change-detection.html">Exp-lookit-change-detection</a></li>
                            <li><a href="../classes/Exp-lookit-dialogue-page.html">Exp-lookit-dialogue-page</a></li>
                            <li><a href="../classes/Exp-lookit-exit-survey.html">Exp-lookit-exit-survey</a></li>
                            <li><a href="../classes/Exp-lookit-geometry-alternation.html">Exp-lookit-geometry-alternation</a></li>
                            <li><a href="../classes/Exp-lookit-geometry-alternation-open.html">Exp-lookit-geometry-alternation-open</a></li>
                            <li><a href="../classes/Exp-lookit-instructions.html">Exp-lookit-instructions</a></li>
                            <li><a href="../classes/Exp-lookit-mood-questionnaire.html">Exp-lookit-mood-questionnaire</a></li>
                            <li><a href="../classes/Exp-lookit-observation.html">Exp-lookit-observation</a></li>
                            <li><a href="../classes/Exp-lookit-preferential-looking.html">Exp-lookit-preferential-looking</a></li>
                            <li><a href="../classes/Exp-lookit-stimuli-preview.html">Exp-lookit-stimuli-preview</a></li>
                            <li><a href="../classes/Exp-lookit-story-page.html">Exp-lookit-story-page</a></li>
                            <li><a href="../classes/Exp-lookit-survey.html">Exp-lookit-survey</a></li>
                            <li><a href="../classes/Exp-lookit-text.html">Exp-lookit-text</a></li>
                            <li><a href="../classes/Exp-lookit-video.html">Exp-lookit-video</a></li>
                            <li><a href="../classes/Exp-lookit-video-assent.html">Exp-lookit-video-assent</a></li>
                            <li><a href="../classes/Exp-lookit-video-consent.html">Exp-lookit-video-consent</a></li>
                            <li><a href="../classes/Exp-lookit-webcam-display.html">Exp-lookit-webcam-display</a></li>
                            <li><a href="../classes/Exp-video-config.html">Exp-video-config</a></li>
                            <li><a href="../classes/Exp-video-config-quality.html">Exp-video-config-quality</a></li>
                            <li><a href="../classes/Expand-assets.html">Expand-assets</a></li>
                            <li><a href="../classes/Full-screen.html">Full-screen</a></li>
                            <li><a href="../classes/Media-reload.html">Media-reload</a></li>
                            <li><a href="../classes/Permute.html">Permute</a></li>
                            <li><a href="../classes/Random-parameter-set.html">Random-parameter-set</a></li>
                            <li><a href="../classes/Select.html">Select</a></li>
                            <li><a href="../classes/Session-record.html">Session-record</a></li>
                            <li><a href="../classes/Video-record.html">Video-record</a></li>
                            <li><a href="../classes/video-recorder.html">video-recorder</a></li>
                        </ul>
                    </div>
              
                  </div>
              </div>
            </div>
        </div>
        <div class="yui3-u-4-5">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: app/components/exp-lookit-change-detection/component.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
import Ember from &#x27;ember&#x27;;
import layout from &#x27;./template&#x27;;
import ExpFrameBaseComponent from &#x27;../exp-frame-base/component&#x27;;
import FullScreen from &#x27;../../mixins/full-screen&#x27;;
import VideoRecord from &#x27;../../mixins/video-record&#x27;;
import ExpandAssets from &#x27;../../mixins/expand-assets&#x27;;
import { audioAssetOptions, videoAssetOptions, imageAssetOptions } from &#x27;../../mixins/expand-assets&#x27;;
import { observer } from &#x27;@ember/object&#x27;;

let {
    $
} = Ember;

// http://stackoverflow.com/a/12646864
function shuffleArrayInPlace(array) {
    for (var i = array.length - 1; i &gt; 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        var temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
    return array;
}

/**
 * @module exp-player
 * @submodule frames
 */

/**
 *
 * Frame for a preferential looking &quot;alternation&quot; or &quot;change detection&quot; paradigm trial,
 * in which separate streams of images are displayed on the left and right of the screen.
 * Typically, on one side images would be alternating between two categories - e.g., images
 * of 8 vs. 16 dots, images of cats vs. dogs - and on the other side the images would all
 * be in the same category.
 *
 *
 * The frame starts with an optional brief &quot;announcement&quot; segment, where an attention-getter
 * video is displayed and audio is played. During this segment, the trial can be paused
 * and restarted.
 *
 *
 * If &#x60;doRecording&#x60; is true (default), then we wait for recording to begin before the
 * actual test trial can begin. We also always wait for all images to pre-load, so that
 * there are no delays in loading images that affect the timing of presentation.
 *
 *
 * You can customize the appearance of the frame: background color overall, color of the
 * two rectangles that contain the image streams, and border of those rectangles. You can
 * also specify how long to present the images for, how long to clear the screen in between
 * image pairs, and how long the test trial should be altogether.
 *
 *
 * You provide four lists of images to use in this frame: &#x60;leftImagesA&#x60;, &#x60;leftImagesB&#x60;,
 * &#x60;rightImagesA&#x60;, and &#x60;rightImagesB&#x60;. The left stream will alternate between images in
 * &#x60;leftImagesA&#x60; and &#x60;leftImagesB&#x60;. The right stream will alternate between images in
 * &#x60;rightImagesA&#x60; and &#x60;rightImagesB&#x60;. They are either presented in random order (default)
 * within those lists, or can be presented in the exact order listed by setting
 * &#x60;randomizeImageOrder&#x60; to false.
 *
 *
 * The timing of all image presentations and the specific images presented is recorded in
 * the event data.
 *
 *
 * This frame is displayed fullscreen; if the frame before it is not, that frame
 * needs to include a manual &quot;next&quot; button so that there&#x27;s a user interaction
 * event to trigger fullscreen mode. (Browsers don&#x27;t allow switching to fullscreen
 * without a user event.) If the user leaves fullscreen, that event is recorded, but the
 * trial is not paused.
 *
 *
 * Specifying media locations:
 *
 *
 * For any parameters that expect a list of audio/video sources, you can EITHER provide
 * a list of src/type pairs with full paths like this:
 &#x60;&#x60;&#x60;json
    [
        {
            &#x27;src&#x27;: &#x27;http://.../video1.mp4&#x27;,
            &#x27;type&#x27;: &#x27;video/mp4&#x27;
        },
        {
            &#x27;src&#x27;: &#x27;http://.../video1.webm&#x27;,
            &#x27;type&#x27;: &#x27;video/webm&#x27;
        }
    ]
 &#x60;&#x60;&#x60;
 * OR you can provide a single string &#x27;stub&#x27;, which will be expanded
 * based on the parameter baseDir and the media types expected - either audioTypes or
 * videoTypes as appropriate. For example, if you provide the audio source &#x60;intro&#x60;
 * and baseDir is https://mystimuli.org/mystudy/, with audioTypes [&#x27;mp3&#x27;, &#x27;ogg&#x27;], then this
 * will be expanded to:
 &#x60;&#x60;&#x60;json
                  [
                         {
                             src: &#x27;https://mystimuli.org/mystudy/mp3/intro.mp3&#x27;,
                             type: &#x27;audio/mp3&#x27;
                         },
                         {
                             src: &#x27;https://mystimuli.org/mystudy/ogg/intro.ogg&#x27;,
                             type: &#x27;audio/ogg&#x27;
                         }
                 ]
 &#x60;&#x60;&#x60;
 * This allows you to simplify your JSON document a bit and also easily switch to a
 * new version of your stimuli without changing every URL. You can mix source objects with
 * full URLs and those using stubs within the same directory. However, any stimuli
 * specified using stubs MUST be
 * organized as expected under baseDir/MEDIATYPE/filename.MEDIATYPE.
 *
 *
 * Example usage:

 &#x60;&#x60;&#x60;json
 &quot;frames&quot;: {
    &quot;alt-trial&quot;: {
        &quot;kind&quot;: &quot;exp-lookit-change-detection&quot;,
        &quot;baseDir&quot;: &quot;https://www.mit.edu/~kimscott/placeholderstimuli/&quot;,
        &quot;videoTypes&quot;: [&quot;mp4&quot;, &quot;webm&quot;],
        &quot;audioTypes&quot;: [&quot;mp3&quot;, &quot;ogg&quot;],
        &quot;trialLength&quot;: 15,
        &quot;attnLength&quot;: 2,
        &quot;fsAudio&quot;: &quot;sample_1&quot;,
        &quot;unpauseAudio&quot;: &quot;return_after_pause&quot;,
        &quot;pauseAudio&quot;: &quot;pause&quot;,
        &quot;videoSources&quot;: &quot;attentiongrabber&quot;,
        &quot;musicSources&quot;: &quot;music_01&quot;,
        &quot;audioSources&quot;: &quot;video_01&quot;,
        &quot;endAudioSources&quot;: &quot;all_done&quot;,
        &quot;border&quot;: &quot;thick solid black&quot;,
        &quot;leftImagesA&quot;: [&quot;apple.jpg&quot;, &quot;orange.jpg&quot;],
        &quot;rightImagesA&quot;: [&quot;square.png&quot;, &quot;tall.png&quot;, &quot;wide.png&quot;],
        &quot;leftImagesB&quot;: [&quot;apple.jpg&quot;, &quot;orange.jpg&quot;],
        &quot;rightImagesB&quot;: [&quot;apple.jpg&quot;, &quot;orange.jpg&quot;],
        &quot;startWithA&quot;: true,
        &quot;randomizeImageOrder&quot;: true,
        &quot;displayMs&quot;: 500,
        &quot;blankMs&quot;: 250,
        &quot;containerColor&quot;: &quot;white&quot;,
        &quot;backgroundColor&quot;: &quot;#abc&quot;,
    }
 }

 * &#x60;&#x60;&#x60;
 * @class Exp-lookit-change-detection
 * @extends Exp-frame-base
 * @uses Full-screen
 * @uses Video-record
 * @uses Expand-assets
 */

// See https://stackoverflow.com/a/56266358
const isColor = (strColor) =&gt; {
    const s = new Option().style;
    s.color = strColor;
    return s.color !== &#x27;&#x27;;
};

export default ExpFrameBaseComponent.extend(FullScreen, VideoRecord, ExpandAssets, {

    type: &#x27;exp-lookit-geometry-alternation&#x27;,
    layout: layout,
    displayFullscreen: true, // force fullscreen for all uses of this component
    fullScreenElementId: &#x27;experiment-player&#x27;,
    fsButtonID: &#x27;fsButton&#x27;,

    // Track state of experiment
    completedAudio: false,
    completedAttn: false,
    currentSegment: &#x27;intro&#x27;, // &#x27;test&#x27; (mutually exclusive)
    alreadyStartedCalibration: false,

    // Override setting in VideoRecord mixin - only use camera if doing recording
    doUseCamera: Ember.computed.alias(&#x27;doRecording&#x27;),
    startRecordingAutomatically: Ember.computed.alias(&#x27;doRecording&#x27;),

    recordingStarted: false,

    imageIndexA: 0,
    imageIndexB: 0,
    doingA: false,
    musicFadeLength: 2000,

    assetsToExpand: {
        &#x27;audio&#x27;: [
            &#x27;audioSources&#x27;,
            &#x27;musicSources&#x27;,
            &#x27;endAudioSources&#x27;,
            &#x27;pauseAudio&#x27;,
            &#x27;unpauseAudio&#x27;,
            &#x27;fsAudio&#x27;
        ],
        &#x27;video&#x27;: [
            &#x27;videoSources&#x27;
        ],
        &#x27;image&#x27;: [
            &#x27;leftImagesA&#x27;,
            &#x27;rightImagesA&#x27;,
            &#x27;leftImagesB&#x27;,
            &#x27;rightImagesB&#x27;
        ]
    },

    readyToStartCalibration: Ember.computed(&#x27;recordingStarted&#x27;, &#x27;completedAudio&#x27;, &#x27;completedAttn&#x27;, &#x27;image_loaded_count&#x27;,
        function() {
            var recordingStarted = false;
            if (this.get(&#x27;session&#x27;).get(&#x27;recorder&#x27;)) {
                recordingStarted = this.get(&#x27;session&#x27;).get(&#x27;recorder&#x27;).get(&#x27;recording&#x27;);
            } else {
                recordingStarted = this.get(&#x27;recordingStarted&#x27;);
            }
            var nImages = this.get(&#x27;leftImagesA_parsed&#x27;).length + this.get(&#x27;leftImagesB_parsed&#x27;).length +
                this.get(&#x27;rightImagesA_parsed&#x27;).length + this.get(&#x27;rightImagesB_parsed&#x27;).length;

            return ((recordingStarted || !this.get(&#x27;doRecording&#x27;)) &amp;&amp; this.get(&#x27;completedAudio&#x27;) &amp;&amp; this.get(&#x27;completedAttn&#x27;) &amp;&amp; this.get(&#x27;image_loaded_count&#x27;) &gt;= nImages);
        }),

    doingIntro: Ember.computed(&#x27;currentSegment&#x27;, function() {
        return (this.get(&#x27;currentSegment&#x27;) === &#x27;intro&#x27;);
    }),

    isPaused: false,
    hasBeenPaused: false,

    // Timers for intro &amp; stimuli
    introTimer: null, // minimum length of intro segment
    stimTimer: null,

    frameSchemaProperties: {
        /**
         * Whether to do webcam recording on this frame
         *
         * @property {Boolean} doRecording
         */
        doRecording: {
            type: &#x27;boolean&#x27;,
            description: &#x27;Whether to do webcam recording&#x27;,
            default: true
        },
        /**
         * minimum amount of time to show attention-getter in seconds. If 0, attention-getter
         * segment is skipped.
         *
         * @property {Number} attnLength
         * @default 0
         */
        attnLength: {
            type: &#x27;number&#x27;,
            description: &#x27;minimum amount of time to show attention-getter in seconds&#x27;,
            default: 0
        },
        /**
         * length of alternation trial in seconds. This refers only to the section of the
         * trial where the alternating image streams are presented - it does not count
         * any announcement phase.
         *
         * @property {Number} trialLength
         * @default 60
         */
        trialLength: {
            type: &#x27;number&#x27;,
            description: &#x27;length of alternation trial in seconds&#x27;,
            default: 60
        },
        /**
         * Sources Array of {src: &#x27;url&#x27;, type: &#x27;MIMEtype&#x27;} objects for
         * instructions during attention-getter video
         *
         * @property {Object[]} audioSources
         */
        audioSources: {
            oneOf: audioAssetOptions,
            description: &#x27;List of objects specifying audio src and type for instructions during attention-getter video&#x27;,
            default: []
        },
        /**
         * Sources Array of {src: &#x27;url&#x27;, type: &#x27;MIMEtype&#x27;} objects for
         * music during trial
         *
         * @property {Object[]} musicSources
         */
        musicSources: {
            oneOf: audioAssetOptions,
            description: &#x27;List of objects specifying audio src and type for music during trial&#x27;,
            default: []
        },
        /**
         * Sources Array of {src: &#x27;url&#x27;, type: &#x27;MIMEtype&#x27;} objects for
         * audio after completion of trial (optional; used for last
         * trial &quot;okay to open your eyes now&quot; announcement)
         *
         * @property {Object[]} endAudioSources
         */
        endAudioSources: {
            oneOf: audioAssetOptions,
            description: &#x27;Supply this to play audio at the end of the trial; list of objects specifying audio src and type&#x27;,
            default: []
        },
        /**
         * Sources Array of {src: &#x27;url&#x27;, type: &#x27;MIMEtype&#x27;} objects for
         * attention-getter video (should be loopable)
         *
         * @property {Object[]} videoSources
         */
        videoSources: {
            oneOf: videoAssetOptions,
            description: &#x27;List of objects specifying video src and type for attention-getter video&#x27;,
            default: []
        },
        /**
         * Sources Array of {src: &#x27;url&#x27;, type: &#x27;MIMEtype&#x27;} objects for
         * audio played upon pausing study
         *
         * @property {Object[]} pauseAudio
         */
        pauseAudio: {
            oneOf: audioAssetOptions,
            description: &#x27;List of objects specifying audio src and type for audio played when pausing study&#x27;,
            default: []
        },
        /**
         * Sources Array of {src: &#x27;url&#x27;, type: &#x27;MIMEtype&#x27;} objects for
         * audio played upon unpausing study
         *
         * @property {Object[]} unpauseAudio
         */
        unpauseAudio: {
            oneOf: audioAssetOptions,
            description: &#x27;List of objects specifying audio src and type for audio played when pausing study&#x27;,
            default: []
        },
        /**
         * Sources Array of {src: &#x27;url&#x27;, type: &#x27;MIMEtype&#x27;} objects for
         * audio played when study is paused due to not being fullscreen
         *
         * @property {Object[]} fsAudio
         */
        fsAudio: {
            oneOf: audioAssetOptions,
            description: &#x27;List of objects specifying audio src and type for audio played when pausing study if study is not fullscreen&#x27;,
            default: []
        },
        /**
         * Whether to start with the &#x27;A&#x27; image list on both left and right. If true, both
         * sides start with their respective A image lists; if false, both lists start with
         * their respective B image lists.
         *
         * @property {Boolean} startWithA
         * @default true
         */
        startWithA: {
            type: &#x27;boolean&#x27;,
            description: &#x27;Whether to start with image list A&#x27;,
            default: true
        },
        /**
         * Whether to randomize image presentation order within the lists leftImagesA,
         * leftImagesB, rightImagesA, and rightImagesB. If true (default), the order
         * of presentation is randomized. Each time all the images in one list have been
         * presented, the order is randomized again for the next &#x27;round.&#x27; If false, the
         * order of presentation is as written in the list. Once all images are presented,
         * we loop back around to the first image and start again.
         *
         * Example of randomization: suppose we have defined
         * &#x60;&#x60;&#x60;
         * leftImagesA: [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;cucumber&#x27;],
         * leftImagesB: [&#x27;aardvark&#x27;, &#x27;bat&#x27;],
         * randomizeImageOrder: true,
         * startWithA: true
         * &#x60;&#x60;&#x60;
         *
         * And suppose the timing is such that we end up with 10 images total. Here is a
         * possible sequence of images shown on the left:
         *
         * [&#x27;banana&#x27;, &#x27;aardvark&#x27;, &#x27;apple&#x27;, &#x27;bat&#x27;, &#x27;cucumber&#x27;, &#x27;bat&#x27;, &#x27;cucumber&#x27;, &#x27;aardvark&#x27;, &#x27;apple&#x27;, &#x27;bat&#x27;]
         *
         * @property {Boolean} randomizeImageOrder
         * @default true
         */
        randomizeImageOrder: {
            type: &#x27;boolean&#x27;,
            description: &#x27;Whether to randomize image presentation order within lists&#x27;,
            default: true
        },
        /**
         * Amount of time to display each image, in milliseconds
         *
         * @property {Number} displayMs
         * @default 750
         */
        displayMs: {
            type: &#x27;number&#x27;,
            description: &#x27;Amount of time to display each image, in milliseconds&#x27;,
            default: 500
        },
        /**
         * Amount of time for blank display between each image, in milliseconds
         *
         * @property {Number} blankMs
         * @default 750
         */
        blankMs: {
            type: &#x27;number&#x27;,
            description: &#x27;Amount of time for blank display between each image, in milliseconds&#x27;,
            default: 250
        },
        /**
         * Format of border to display around alternation streams, if any. See
         * https://developer.mozilla.org/en-US/docs/Web/CSS/border for syntax.
         *
         * @property {String} border
         * @default &#x27;thin solid gray&#x27;
         */
        border: {
            type: &#x27;string&#x27;,
            description: &#x27;Amount of time for blank display between each image, in milliseconds&#x27;,
            default: &#x27;thin solid gray&#x27;
        },
        /**
         * Color of background. See https://developer.mozilla.org/en-US/docs/Web/CSS/color_value
         * for acceptable syntax: can use color names (&#x27;blue&#x27;, &#x27;red&#x27;, &#x27;green&#x27;, etc.), or
         * rgb hex values (e.g. &#x27;#800080&#x27; - include the &#x27;#&#x27;)
         *
         * @property {String} backgroundColor
         * @default &#x27;white&#x27;
         */
        backgroundColor: {
            type: &#x27;string&#x27;,
            description: &#x27;Color of background&#x27;,
            default: &#x27;white&#x27;
        },
        /**
         * Color of image stream container, if different from overall background.
         * Defaults to backgroundColor if one is provided.
         * https://developer.mozilla.org/en-US/docs/Web/CSS/color_value
         * for acceptable syntax: can use color names (&#x27;blue&#x27;, &#x27;red&#x27;, &#x27;green&#x27;, etc.), or
         * rgb hex values (e.g. &#x27;#800080&#x27; - include the &#x27;#&#x27;)
         *
         * @property {String} containerColor
         * @default &#x27;white&#x27;
         */
        containerColor: {
            type: &#x27;string&#x27;,
            description: &#x27;Color of image stream container&#x27;,
            default: &#x27;white&#x27;
        },
        /**
         * Set A of images to display on left of screen. Left stream will alternate between
         * images from set A and from set B. Elements of list can be full URLs or relative
         * paths starting from &#x60;baseDir&#x60;.
         *
         * @property {String[]} leftImagesA
         */
        leftImagesA: {
            type: &#x27;array&#x27;,
            description: &#x27;Set A of images to display on left of screen&#x27;,
            default: [],
            items: {
                oneOf: imageAssetOptions
            }
        },
        /**
         * Set B of images to display on left of screen. Left stream will alternate between
         * images from set A and from set B. Elements of list can be full URLs or relative
         * paths starting from &#x60;baseDir&#x60;.
         *
         * @property {String[]} leftImagesB
         */
        leftImagesB: {
            type: &#x27;array&#x27;,
            description: &#x27;Set B of images to display on left of screen&#x27;,
            default: [],
            items: {
                oneOf: imageAssetOptions
            }
        },
        /**
         * Set A of images to display on right of screen. Right stream will alternate between
         * images from set A and from set B. Elements of list can be full URLs or relative
         * paths starting from &#x60;baseDir&#x60;.
         *
         * @property {String[]} rightImagesA
         */
        rightImagesA: {
            type: &#x27;array&#x27;,
            description: &#x27;Set A of images to display on right of screen&#x27;,
            default: [],
            items: {
                oneOf: imageAssetOptions
            }
        },
        /**
         * Set B of images to display on right of screen. Right stream will alternate between
         * images from set A and from set B. Elements of list can be full URLs or relative
         * paths starting from &#x60;baseDir&#x60;.
         *
         * @property {String[]} rightImagesA
         */
        rightImagesB: {
            type: &#x27;array&#x27;,
            description: &#x27;Set B of images to display on right of screen&#x27;,
            default: [],
            items: {
                oneOf: imageAssetOptions
            }
        }
    },

    meta: {
        name: &#x27;ExpLookitGeometryAlternation&#x27;,
        description: &#x27;Frame to implement specific test trial structure for geometry alternation experiment. Includes announcement and alternation (test) phases. During &quot;alternation,&quot; two streams of triangles are shown, in rectangles on the left and right of the screen: one one side both size and shape change, on the other only size changes. Frame is displayed fullscreen and video recording is conducted during test.&#x27;,
        data: {
            type: &#x27;object&#x27;,
            properties: {
               /**
                * Sequence of images shown on the left
                * @method leftSequence
                */
                leftSequence: {
                    type: &#x27;Object&#x27;
                },
               /**
                * Sequence of images shown on the right
                * @method rightSequence
                */
                rightSequence: {
                    type: &#x27;Object&#x27;
                },
                videoId: {
                    type: &#x27;string&#x27;
                },
               /**
                * Whether this trial was paused
                * @method hasBeenPaused
                */
                hasBeenPaused: {
                    type: &#x27;boolean&#x27;
                }
            }
        }
    },

    calObserver: observer(&#x27;readyToStartCalibration&#x27;, function(frame) {
        if (frame.get(&#x27;readyToStartCalibration&#x27;) &amp;&amp; frame.get(&#x27;currentSegment&#x27;) === &#x27;intro&#x27;) {
            if (!frame.checkFullscreen()) {
                frame.pauseStudy();
            } else {
                frame.set(&#x27;currentSegment&#x27;, &#x27;test&#x27;);
            }
        }
    }),

    segmentObserver: observer(&#x27;currentSegment&#x27;, function(frame) {
        // Don&#x27;t trigger starting intro; that&#x27;ll be done manually.
        if (frame.get(&#x27;currentSegment&#x27;) === &#x27;test&#x27;) {
            frame.startTrial();
        }
    }),

    didRender() {
        this._super(...arguments);
        if (this.get(&#x27;doingCalibration&#x27;) &amp;&amp; !this.get(&#x27;alreadyStartedCalibration&#x27;)) {
            this.set(&#x27;alreadyStartedCalibration&#x27;, true);
            this.startCalibration();
        }
    },

    actions: {
        // When intro audio is complete
        endAudio() {
            this.set(&#x27;completedAudio&#x27;, true);
            this.notifyPropertyChange(&#x27;readyToStartCalibration&#x27;);
        },

        finish() {

            // Call this something separate from next because stopRecorder promise needs
            // to call next AFTER recording is stopped and we don&#x27;t want this to have
            // already been destroyed at that point.
            /**
             * Just before stopping webcam video capture
             *
             * @event stoppingCapture
            */
            var _this = this;
            this.stopRecorder().then(() =&gt; {
                _this.set(&#x27;stoppedRecording&#x27;, true);
                _this.send(&#x27;next&#x27;);
                return;
            }, () =&gt; {
                _this.send(&#x27;next&#x27;);
                return;
            });

            this._super(...arguments);
        }

    },

    startIntro() {
        // Allow pausing during intro
        var _this = this;
        $(document).off(&#x27;keyup.pauser&#x27;);
        $(document).on(&#x27;keyup.pauser&#x27;, function(e) {_this.handleSpace(e, _this);});

        // Start placeholder video right away
        /**
         * Immediately before starting intro/announcement segment
         *
         * @event startIntro
         */
        this.send(&#x27;setTimeEvent&#x27;, &#x27;startIntro&#x27;);
        if (this.get(&#x27;attnLength&#x27;)) {
            $(&#x27;#player-video&#x27;)[0].play();
            // Set a timer for the minimum length for the intro/break
            $(&#x27;#player-audio&#x27;)[0].play();
            this.set(&#x27;introTimer&#x27;, window.setTimeout(function() {
                _this.set(&#x27;completedAttn&#x27;, true);
                _this.notifyPropertyChange(&#x27;readyToStartCalibration&#x27;);
            }, _this.get(&#x27;attnLength&#x27;) * 1000));
        } else {
            _this.set(&#x27;completedAttn&#x27;, true);
            _this.set(&#x27;completedAudio&#x27;, true);
            _this.notifyPropertyChange(&#x27;readyToStartCalibration&#x27;);
        }
    },

    startTrial() {

        var _this = this;
        /**
         * Immediately before starting test trial segment
         *
         * @event startTestTrial
         */
        _this.send(&#x27;setTimeEvent&#x27;, &#x27;startTestTrial&#x27;);

        // Begin playing music; fade in and set to fade out at end of trial
        var $musicPlayer = $(&#x27;#player-music&#x27;);
        $musicPlayer.prop(&#x27;volume&#x27;, 0.1);
        $musicPlayer[0].play();
        $musicPlayer.animate({volume: 1}, _this.get(&#x27;musicFadeLength&#x27;));
        window.setTimeout(function() {
            $musicPlayer.animate({volume: 0}, _this.get(&#x27;musicFadeLength&#x27;));
        }, _this.get(&#x27;trialLength&#x27;) * 1000 - _this.get(&#x27;musicFadeLength&#x27;));

        // Start presenting triangles and set to stop after trial length
        $(&#x27;#allstimuli&#x27;).show();
        _this.presentImages();
        window.setTimeout(function() {
                window.clearTimeout(_this.get(&#x27;stimTimer&#x27;));
                _this.clearImages();
                _this.endTrial();
            }, _this.get(&#x27;trialLength&#x27;) * 1000);
    },

    // When triangles have been shown for time indicated: play end-audio if
    // present, or just move on.
    endTrial() {
        this.stopRecorder();
        if (this.get(&#x27;endAudioSources&#x27;).length) {
            $(&#x27;#player-endaudio&#x27;)[0].play();
        } else {
            this.send(&#x27;finish&#x27;);
        }
    },

    clearImages() {
        /**
         * Records each time images are cleared from display
         *
         * @event clearImages
        */
        this.send(&#x27;setTimeEvent&#x27;, &#x27;clearImages&#x27;);
        $(&#x27;.stream-container&#x27;).html(&#x27;&#x27;);
    },

    presentImages() {
        var A = this.get(&#x27;doingA&#x27;);
        var leftImageList = A ? this.get(&#x27;leftImagesA_parsed&#x27;) : this.get(&#x27;leftImagesB_parsed&#x27;);
        var rightImageList = A ? this.get(&#x27;rightImagesA_parsed&#x27;) : this.get(&#x27;rightImagesB_parsed&#x27;);
        var imageIndex = A ? this.get(&#x27;imageIndexA&#x27;) : this.get(&#x27;imageIndexB&#x27;);

        var leftImageIndex = imageIndex % leftImageList.length;
        var rightImageIndex = imageIndex % rightImageList.length;

        if (leftImageIndex == 0 &amp;&amp; this.get(&#x27;randomizeImageOrder&#x27;)) {
            shuffleArrayInPlace(leftImageList);
        }
        if (rightImageIndex == 0 &amp;&amp; this.get(&#x27;randomizeImageOrder&#x27;)) {
            shuffleArrayInPlace(rightImageList);
        }
        if (A) {
            this.set(&#x27;imageIndexA&#x27;, this.get(&#x27;imageIndexA&#x27;) + 1);
        } else {
            this.set(&#x27;imageIndexB&#x27;, this.get(&#x27;imageIndexB&#x27;) + 1);
        }
        this.set(&#x27;doingA&#x27;, !this.get(&#x27;doingA&#x27;));
        var _this = this;
        _this.clearImages();
        _this.set(&#x27;stimTimer&#x27;, window.setTimeout(function() {
            $(&#x27;#left-stream-container&#x27;).html(&#x60;&lt;img src=${leftImageList[leftImageIndex]} class=&quot;stim-image&quot; alt=&quot;left image&quot;&gt;&#x60;);
            $(&#x27;#right-stream-container&#x27;).html(&#x60;&lt;img src=${rightImageList[rightImageIndex]} class=&quot;stim-image&quot; alt=&quot;right image&quot;&gt;&#x60;);
            /**
             * Immediately after making images visible
             *
             * @event presentImages
             * @param {String} left url of left image
             * @param {String} right url of right image
             */
            _this.send(&#x27;setTimeEvent&#x27;, &#x27;presentImages&#x27;, {
                left: leftImageList[leftImageIndex],
                right: rightImageList[rightImageIndex]
            });
            _this.set(&#x27;stimTimer&#x27;, window.setTimeout(function() {
                _this.presentImages();
            }, _this.get(&#x27;displayMs&#x27;)));
        }, _this.get(&#x27;blankMs&#x27;)));
    },

    handleSpace(event, frame) {
        if (frame.checkFullscreen() || !frame.isPaused) {
            if (event.which === 32) { // space
                frame.pauseStudy();
            }
        }
    },

    // Pause/unpause study; only called if doing intro.
    pauseStudy() {

        $(&#x27;#player-audio&#x27;)[0].pause();
        $(&#x27;#player-audio&#x27;)[0].currentTime = 0;
        $(&#x27;#player-pause-audio&#x27;)[0].pause();
        $(&#x27;#player-pause-audio&#x27;)[0].currentTime = 0;
        $(&#x27;#player-pause-audio-leftfs&#x27;)[0].pause();
        $(&#x27;#player-pause-audio-leftfs&#x27;)[0].currentTime = 0;

        this.set(&#x27;completedAudio&#x27;, false);
        this.set(&#x27;completedAttn&#x27;, false);

        Ember.run.once(this, () =&gt; {
            this.set(&#x27;hasBeenPaused&#x27;, true);
            var wasPaused = this.get(&#x27;isPaused&#x27;);
            this.set(&#x27;currentSegment&#x27;, &#x27;intro&#x27;);

            // Currently paused: RESUME
            if (wasPaused) {
                try {
                    this.resumeRecorder();
                } catch (_) {
                    return;
                }
                this.startIntro();
                this.set(&#x27;isPaused&#x27;, false);
            } else { // Not currently paused: PAUSE
                window.clearTimeout(this.get(&#x27;introTimer&#x27;));
                this.pauseRecorder(true);
                if (this.checkFullscreen()) {
                    $(&#x27;#player-pause-audio&#x27;)[0].play();
                } else {
                    $(&#x27;#player-pause-audio-leftfs&#x27;)[0].play();
                }
                this.set(&#x27;isPaused&#x27;, true);
            }
        });

    },

    image_loaded_count: 0,

    didInsertElement() {
        this._super(...arguments);
        this.set(&#x27;doingA&#x27;, this.get(&#x27;startWithA&#x27;));
        this.send(&#x27;showFullscreen&#x27;);
        this.notifyPropertyChange(&#x27;readyToStartCalibration&#x27;);
        var _this = this;

        $.each([this.get(&#x27;leftImagesA_parsed&#x27;), this.get(&#x27;leftImagesB_parsed&#x27;), this.get(&#x27;rightImagesA_parsed&#x27;), this.get(&#x27;rightImagesB_parsed&#x27;)],
            function(idx, imgList) {
                $.each(imgList, function(idx, url) {
                    var img = new Image();
                    img.onload = function() { // set onload fn before source to ensure we catch it
                        _this.set(&#x27;image_loaded_count&#x27;, _this.get(&#x27;image_loaded_count&#x27;) + 1);
                        _this.notifyPropertyChange(&#x27;readyToStartCalibration&#x27;);
                    };
                    img.onerror = function() {
                        _this.set(&#x27;image_loaded_count&#x27;, _this.get(&#x27;image_loaded_count&#x27;) + 1);
                        _this.notifyPropertyChange(&#x27;readyToStartCalibration&#x27;);
                        console.error(&#x27;Unable to load image at &#x27;, url, &#x27; - will skip loading but this may cause the exp-lookit-change-detection frame to fail&#x27;);
                    };
                    img.src = url;
                });
            });

        if (this.get(&#x27;border&#x27;).includes(&#x27;;&#x27;)) {
            console.warn(&#x27;Invalid border css provided to exp-lookit-change-detection; not applying.&#x27;);
        } else {
            $(&#x27;#allstimuli div.stream-container&#x27;).css(&#x27;border&#x27;, this.get(&#x27;border&#x27;));
        }

        if (isColor(this.get(&#x27;backgroundColor&#x27;))) {
            $(&#x27;div.exp-lookit-change-detection&#x27;).css(&#x27;background-color&#x27;, this.get(&#x27;backgroundColor&#x27;));
        } else {
            console.warn(&#x27;Invalid background color provided to exp-lookit-change-detection; not applying.&#x27;);
        }

        if (isColor(this.get(&#x27;containerColor&#x27;))) {
            $(&#x27;div.exp-lookit-change-detection div.stream-container&#x27;).css(&#x27;background-color&#x27;, this.get(&#x27;containerColor&#x27;));
        } else {
            console.warn(&#x27;Invalid container color provided to exp-lookit-change-detection; not applying.&#x27;);
        }

        $(&#x27;#allstimuli&#x27;).hide();
        this.startIntro();
    },

    willDestroyElement() { // remove event handler
        $(document).off(&#x27;keyup.pauser&#x27;);
        window.clearInterval(this.get(&#x27;introTimer&#x27;));
        window.clearInterval(this.get(&#x27;stimTimer&#x27;));
        this._super(...arguments);
    },

    /**
     * Observer that starts recording once recorder is ready. Override to do additional
     * stuff at this point!
     * @method whenPossibleToRecord
     * @private
     */
    whenPossibleToRecord: observer(&#x27;recorder.hasCamAccess&#x27;, &#x27;recorderReady&#x27;, function() {
        if (this.get(&#x27;doRecording&#x27;)) {
            var _this = this;
            if (this.get(&#x27;recorder.hasCamAccess&#x27;) &amp;&amp; this.get(&#x27;recorderReady&#x27;)) {
                this.startRecorder().then(() =&gt; {
                    _this.set(&#x27;recorderReady&#x27;, false);
                    _this.set(&#x27;recordingStarted&#x27;, true);
                    _this.notifyPropertyChange(&#x27;readyToStartCalibration&#x27;);
                });
            }
        }
    }),

    /**
     * Observer that starts recording once sessionrecorder is ready.
     * @method whenPossibleToRecordSession
     * @private
     */
    whenPossibleToRecordSession: observer(&#x27;sessionRecorder.hasCamAccess&#x27;, &#x27;sessionRecorderReady&#x27;, function() {
        if (this.get(&#x27;startSessionRecording&#x27;)) {
            var _this = this;
            if (this.get(&#x27;sessionRecorder.hasCamAccess&#x27;) &amp;&amp; this.get(&#x27;sessionRecorderReady&#x27;)) {
                this.startSessionRecorder().then(() =&gt; {
                    _this.set(&#x27;sessionRecorderReady&#x27;, false);
                    _this.set(&#x27;recordingStarted&#x27;, true);
                    _this.notifyPropertyChange(&#x27;readyToStartCalibration&#x27;);
                });
            }
        }
    }),

});

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
